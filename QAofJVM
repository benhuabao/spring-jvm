1)内存泄露和内存溢出的区别
    内存泄露是不再使用的对象一直不能被及时回收,持续占用空间,导致内存浪费,因此很容易引起内存溢出
    但是内存溢出不一定是内存泄露导致的

2)major gc与full gc的区别
    Major gc在很多资料中是等同于Full gc的.很都的性能检测工具中只有minor gc和full gc, 一般情况下,
    一次full gc将会对年轻代/老年代/元空间/以及堆外内存进行垃圾回收.
    触发GC的原因很多,当年轻代进入老年代的对象太大,并且比老年代剩余的空间大小还大,会触发full gc,当老
    年代空间使用率超过某个阈值时,会触发full gc,元空间不足的时候,也触发full gc,调用System.gc(),也会
    安排full gc.

3)什么是直接内存
    直接内存是Java堆外,直接向系统申请的内存空间,通常访问直接内存的速度是大于访问堆的速度.因此,读写频繁的
    数据可能需要放在直接内存中.由于是在堆外.因此大小不会直接受限于Xmx指定的最大堆大小,但是系统内存是有限的
    Java堆和直接内存的综合受限于操作系统能给的最大内存

4)垃圾判断方式
    引用计数法:如果某个地方引用了这个对象就+1.如果失效了就-1,当总和为0,就会回收.但是?!jvm没有使用这种方法
    因为无法判定互相应用的情况
    引用链法:通过一种GC ROOT对象来判断,如果有一条链能达到GC ,就不能回收,如果不能到达GC ROOT,就可以回收.

5)不可到达的对象就一定要被回收吗 (引用链法存疑)
    这就涉及到了引用链法,即使在可达性分析中不可达的对象,也不是非死不可的.要真正宣告死亡,至少要经历两次标记过程
    
    第一次标记&筛选:对象被认为不可达后,会被第一次标记&准备被筛选.
    a:不筛选:判断死亡,就等死
    b:筛选:从"即将回收池"里头取出来,进入下一阶段,第二次筛选
    筛选标准:如果对象没有finalize()方法或者finalize()方法已被虚拟机调用过,就不筛选.

    第二次标记&筛选:
    筛选标准:在执行finalize过程呢中,对象要是还没有与GC ROOTZ关联上当话,那么该对象被判断为死亡,不筛选,留在等死
    集合里面,等待回收

    方式:该对象被放在一个F-Queue队列中,并执行该对象的finalize().

6)为什么要区分新生代和老年代
    目前虚拟机都采用的是分代收集算法,如果将Java堆分为新生代老年代,就能根据特点来选择合适的垃圾收集算法

7)方法中的无用类回收
    如何判断一个类是不用的呢.需要同时满足三个条件
    a-该类的所有实例都已经被回收
    b-加载该类的ClassLoader已经被回收
    c-该类对应的java.lang.Class对象没有任何地方被引用,无法在任何地方通过反射访问该类的方法.